{
  "SWC-100": {
    "markdown": "# Title \nFunction Default Visibility\n\n## Relationships \n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nFunctions that do not have a function visibility type specified are `public` by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.     \n\n## Remediation\n\nFunctions can be specified as being `external`, `public`, `internal` or `private`. It is recommended to make a conscious decision on which visibility type is appropriate for a function. This can dramatically reduce the attack surface of a contract system. \n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#visibility)\n",
    "content": {
      "Title": "Function Default Visibility",
      "Relationships": "[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)",
      "Description": "Functions that do not have a function visibility type specified are `public` by default. This can lead to a vulnerability if a developer forgot to set the visibility and a malicious user is able to make unauthorized or unintended state changes.",
      "Remediation": "Functions can be specified as being `external`, `public`, `internal` or `private`. It is recommended to make a conscious decision on which visibility type is appropriate for a function. This can dramatically reduce the attack surface of a contract system."
    }
  },
  "SWC-101": {
    "markdown": "# Title \nInteger Overflow and Underflow\n\n## Relationships\n[CWE-682: Incorrect Calculation](https://cwe.mitre.org/data/definitions/682.html) \n\n## Description \n\nAn overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.\n\n## Remediation\n\nIt is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.\n\n## References \n- [Ethereum Smart Contract Best Practices - Integer Overflow and Underflow](https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow)\n",
    "content": {
      "Title": "Integer Overflow and Underflow\n\n## Relationships\n[CWE-682: Incorrect Calculation](https://cwe.mitre.org/data/definitions/682.html) \n\n## Description \n\nAn overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.\n\n## Remediation\n\nIt is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.\n\n## References \n- [Ethereum Smart Contract Best Practices - Integer Overflow and Underflow](https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow)",
      "Relationships": "# Title \nInteger Overflow and Underflow\n\n## Relationships\n[CWE-682: Incorrect Calculation](https://cwe.mitre.org/data/definitions/682.html) \n\n## Description \n\nAn overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.\n\n## Remediation\n\nIt is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.\n\n## References \n- [Ethereum Smart Contract Best Practices - Integer Overflow and Underflow](https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow)",
      "Description": "# Title \nInteger Overflow and Underflow\n\n## Relationships\n[CWE-682: Incorrect Calculation](https://cwe.mitre.org/data/definitions/682.html) \n\n## Description \n\nAn overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.\n\n## Remediation\n\nIt is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.\n\n## References \n- [Ethereum Smart Contract Best Practices - Integer Overflow and Underflow](https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow)",
      "Remediation": "# Title \nInteger Overflow and Underflow\n\n## Relationships\n[CWE-682: Incorrect Calculation](https://cwe.mitre.org/data/definitions/682.html) \n\n## Description \n\nAn overflow/underflow happens when an arithmetic operation reaches the maximum or minimum size of a type. For instance if a number is stored in the uint8 type, it means that the number is stored in a 8 bits unsigned number ranging from 0 to 2^8-1. In computer programming, an integer overflow occurs when an arithmetic operation attempts to create a numeric value that is outside of the range that can be represented with a given number of bits – either larger than the maximum or lower than the minimum representable value.\n\n## Remediation\n\nIt is recommended to use vetted safe math libraries for arithmetic operations consistently throughout the smart contract system.\n\n## References \n- [Ethereum Smart Contract Best Practices - Integer Overflow and Underflow](https://consensys.github.io/smart-contract-best-practices/known_attacks/#integer-overflow-and-underflow)"
    }
  },
  "SWC-102": {
    "markdown": "# Title \nOutdated Compiler Version\n\n## Relationships\n[CWE-937: Using Components with Known Vulnerabilities](http://cwe.mitre.org/data/definitions/937.html)\n\n## Description \n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.\n\n## Remediation\n\nIt is recommended to use a recent version of the Solidity compiler.  \n\n## References \n- [Solidity Release Notes](https://github.com/ethereum/solidity/releases)\n- [Etherscan Solidity Bug Info](https://etherscan.io/solcbuginfo)\n",
    "content": {
      "Title": "Outdated Compiler Version\n\n## Relationships\n[CWE-937: Using Components with Known Vulnerabilities](http://cwe.mitre.org/data/definitions/937.html)\n\n## Description \n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.\n\n## Remediation\n\nIt is recommended to use a recent version of the Solidity compiler.  \n\n## References \n- [Solidity Release Notes](https://github.com/ethereum/solidity/releases)\n- [Etherscan Solidity Bug Info](https://etherscan.io/solcbuginfo)",
      "Relationships": "# Title \nOutdated Compiler Version\n\n## Relationships\n[CWE-937: Using Components with Known Vulnerabilities](http://cwe.mitre.org/data/definitions/937.html)\n\n## Description \n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.\n\n## Remediation\n\nIt is recommended to use a recent version of the Solidity compiler.  \n\n## References \n- [Solidity Release Notes](https://github.com/ethereum/solidity/releases)\n- [Etherscan Solidity Bug Info](https://etherscan.io/solcbuginfo)",
      "Description": "# Title \nOutdated Compiler Version\n\n## Relationships\n[CWE-937: Using Components with Known Vulnerabilities](http://cwe.mitre.org/data/definitions/937.html)\n\n## Description \n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.\n\n## Remediation\n\nIt is recommended to use a recent version of the Solidity compiler.  \n\n## References \n- [Solidity Release Notes](https://github.com/ethereum/solidity/releases)\n- [Etherscan Solidity Bug Info](https://etherscan.io/solcbuginfo)",
      "Remediation": "# Title \nOutdated Compiler Version\n\n## Relationships\n[CWE-937: Using Components with Known Vulnerabilities](http://cwe.mitre.org/data/definitions/937.html)\n\n## Description \n\nUsing an outdated compiler version can be problematic especially if there are publicly disclosed bugs and issues that affect the current compiler version.\n\n## Remediation\n\nIt is recommended to use a recent version of the Solidity compiler.  \n\n## References \n- [Solidity Release Notes](https://github.com/ethereum/solidity/releases)\n- [Etherscan Solidity Bug Info](https://etherscan.io/solcbuginfo)"
    }
  },
  "SWC-103": {
    "markdown": "# Title \nFloating Pragma \n\n## Relationships\n[CWE-664: Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\n## Description \n\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n## Remediation\n\nLock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen. \n\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\n## References \n- [Ethereum Smart Contract Best Practices - Lock pragmas to specific compiler version](https://consensys.github.io/smart-contract-best-practices/recommendations/#lock-pragmas-to-specific-compiler-version)\n\n\n",
    "content": {
      "Title": "Floating Pragma \n\n## Relationships\n[CWE-664: Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\n## Description \n\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n## Remediation\n\nLock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen. \n\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\n## References \n- [Ethereum Smart Contract Best Practices - Lock pragmas to specific compiler version](https://consensys.github.io/smart-contract-best-practices/recommendations/#lock-pragmas-to-specific-compiler-version)",
      "Relationships": "# Title \nFloating Pragma \n\n## Relationships\n[CWE-664: Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\n## Description \n\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n## Remediation\n\nLock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen. \n\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\n## References \n- [Ethereum Smart Contract Best Practices - Lock pragmas to specific compiler version](https://consensys.github.io/smart-contract-best-practices/recommendations/#lock-pragmas-to-specific-compiler-version)",
      "Description": "# Title \nFloating Pragma \n\n## Relationships\n[CWE-664: Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\n## Description \n\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n## Remediation\n\nLock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen. \n\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\n## References \n- [Ethereum Smart Contract Best Practices - Lock pragmas to specific compiler version](https://consensys.github.io/smart-contract-best-practices/recommendations/#lock-pragmas-to-specific-compiler-version)",
      "Remediation": "# Title \nFloating Pragma \n\n## Relationships\n[CWE-664: Improper Control of a Resource Through its Lifetime](https://cwe.mitre.org/data/definitions/664.html)\n\n## Description \n\nContracts should be deployed with the same compiler version and flags that they have been tested with thoroughly. Locking the pragma helps to ensure that contracts do not accidentally get deployed using, for example, an outdated compiler version that might introduce bugs that affect the contract system negatively.\n\n## Remediation\n\nLock the pragma version and also consider known bugs (https://github.com/ethereum/solidity/releases) for the compiler version that is chosen. \n\nPragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\n## References \n- [Ethereum Smart Contract Best Practices - Lock pragmas to specific compiler version](https://consensys.github.io/smart-contract-best-practices/recommendations/#lock-pragmas-to-specific-compiler-version)"
    }
  },
  "SWC-104": {
    "markdown": "# Title \nUnchecked Call Return Value\n\n## Relationships\n[CWE-252: Unchecked Return Value](https://cwe.mitre.org/data/definitions/252.html)\n\n## Description \n\nThe return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.\n\n## Remediation\n\nIf you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.\n\n## References \n- [Ethereum Smart Contract Best Practices - Handle errors in external calls](https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls)\n",
    "content": {
      "Title": "Unchecked Call Return Value\n\n## Relationships\n[CWE-252: Unchecked Return Value](https://cwe.mitre.org/data/definitions/252.html)\n\n## Description \n\nThe return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.\n\n## Remediation\n\nIf you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.\n\n## References \n- [Ethereum Smart Contract Best Practices - Handle errors in external calls](https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls)",
      "Relationships": "# Title \nUnchecked Call Return Value\n\n## Relationships\n[CWE-252: Unchecked Return Value](https://cwe.mitre.org/data/definitions/252.html)\n\n## Description \n\nThe return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.\n\n## Remediation\n\nIf you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.\n\n## References \n- [Ethereum Smart Contract Best Practices - Handle errors in external calls](https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls)",
      "Description": "# Title \nUnchecked Call Return Value\n\n## Relationships\n[CWE-252: Unchecked Return Value](https://cwe.mitre.org/data/definitions/252.html)\n\n## Description \n\nThe return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.\n\n## Remediation\n\nIf you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.\n\n## References \n- [Ethereum Smart Contract Best Practices - Handle errors in external calls](https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls)",
      "Remediation": "# Title \nUnchecked Call Return Value\n\n## Relationships\n[CWE-252: Unchecked Return Value](https://cwe.mitre.org/data/definitions/252.html)\n\n## Description \n\nThe return value of a message call is not checked. Execution will resume even if the called contract throws an exception. If the call fails accidentally or an attacker forces the call to fail, this may cause unexpected behaviour in the subsequent program logic.\n\n## Remediation\n\nIf you choose to use low-level call methods, make sure to handle the possibility that the call will fail by checking the return value.\n\n## References \n- [Ethereum Smart Contract Best Practices - Handle errors in external calls](https://consensys.github.io/smart-contract-best-practices/recommendations/#handle-errors-in-external-calls)"
    }
  },
  "SWC-105": {
    "markdown": "# Title \nUnprotected Ether Withdrawal\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.\n\nThis bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime bytecode and can be called by anyone to re-initialize the contract.\n\n## Remediation\n\nImplement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.\n\n## References \n\n- [Rubixi smart contract](https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code)\n",
    "content": {
      "Title": "Unprotected Ether Withdrawal\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.\n\nThis bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime bytecode and can be called by anyone to re-initialize the contract.\n\n## Remediation\n\nImplement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.\n\n## References \n\n- [Rubixi smart contract](https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code)",
      "Relationships": "# Title \nUnprotected Ether Withdrawal\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.\n\nThis bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime bytecode and can be called by anyone to re-initialize the contract.\n\n## Remediation\n\nImplement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.\n\n## References \n\n- [Rubixi smart contract](https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code)",
      "Description": "# Title \nUnprotected Ether Withdrawal\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.\n\nThis bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime bytecode and can be called by anyone to re-initialize the contract.\n\n## Remediation\n\nImplement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.\n\n## References \n\n- [Rubixi smart contract](https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code)",
      "Remediation": "# Title \nUnprotected Ether Withdrawal\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can withdraw some or all Ether from the contract account.\n\nThis bug is sometimes caused by unintentionally exposing initialization functions. By wrongly naming a function intended to be a constructor, the constructor code ends up in the runtime bytecode and can be called by anyone to re-initialize the contract.\n\n## Remediation\n\nImplement controls so withdrawals can only be triggered by authorized parties or according to the specs of the smart contract system.\n\n## References \n\n- [Rubixi smart contract](https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code)"
    }
  },
  "SWC-106": {
    "markdown": "# Title \nUnprotected SELFDESTRUCT/SUICIDE Instruction\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\n\n## Remediation\n\nConsider removing the self-destruct functionality unless it is absolutely required. If there is valid use-case, it is recommended to implement multisig scheme so that multiple parties must approve the self-destruct action.\n\n## References \n- [Parity \"I accidentally killed it\" bug](https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)\n",
    "content": {
      "Title": "Unprotected SELFDESTRUCT/SUICIDE Instruction\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\n\n## Remediation\n\nConsider removing the self-destruct functionality unless it is absolutely required. If there is valid use-case, it is recommended to implement multisig scheme so that multiple parties must approve the self-destruct action.\n\n## References \n- [Parity \"I accidentally killed it\" bug](https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)",
      "Relationships": "# Title \nUnprotected SELFDESTRUCT/SUICIDE Instruction\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\n\n## Remediation\n\nConsider removing the self-destruct functionality unless it is absolutely required. If there is valid use-case, it is recommended to implement multisig scheme so that multiple parties must approve the self-destruct action.\n\n## References \n- [Parity \"I accidentally killed it\" bug](https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)",
      "Description": "# Title \nUnprotected SELFDESTRUCT/SUICIDE Instruction\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\n\n## Remediation\n\nConsider removing the self-destruct functionality unless it is absolutely required. If there is valid use-case, it is recommended to implement multisig scheme so that multiple parties must approve the self-destruct action.\n\n## References \n- [Parity \"I accidentally killed it\" bug](https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)",
      "Remediation": "# Title \nUnprotected SELFDESTRUCT/SUICIDE Instruction\n\n## Relationships\n[CWE-284: Improper Access Control](https://cwe.mitre.org/data/definitions/284.html)\n\n## Description \n\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\n\n## Remediation\n\nConsider removing the self-destruct functionality unless it is absolutely required. If there is valid use-case, it is recommended to implement multisig scheme so that multiple parties must approve the self-destruct action.\n\n## References \n- [Parity \"I accidentally killed it\" bug](https://www.parity.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)"
    }
  },
  "SWC-107": {
    "markdown": "# Title \nReentrancy\n\n## Relationships\n[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)\n\n## Description\n\nOne of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.\n\n## Remediation\n\nThe best practices to avoid Reentrancy weaknesses are: \n\n- Use `transfer()` instead of `contract.call()` to transfer Ether to untrusted addresses. \n- When using low-level calls, make sure all internal state changes are performed before the call is executed.\n\n## References \n\n- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy)\n",
    "content": {
      "Title": "Reentrancy\n\n## Relationships\n[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)\n\n## Description\n\nOne of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.\n\n## Remediation\n\nThe best practices to avoid Reentrancy weaknesses are: \n\n- Use `transfer()` instead of `contract.call()` to transfer Ether to untrusted addresses. \n- When using low-level calls, make sure all internal state changes are performed before the call is executed.\n\n## References \n\n- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy)",
      "Relationships": "# Title \nReentrancy\n\n## Relationships\n[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)\n\n## Description\n\nOne of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.\n\n## Remediation\n\nThe best practices to avoid Reentrancy weaknesses are: \n\n- Use `transfer()` instead of `contract.call()` to transfer Ether to untrusted addresses. \n- When using low-level calls, make sure all internal state changes are performed before the call is executed.\n\n## References \n\n- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy)",
      "Description": "# Title \nReentrancy\n\n## Relationships\n[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)\n\n## Description\n\nOne of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.\n\n## Remediation\n\nThe best practices to avoid Reentrancy weaknesses are: \n\n- Use `transfer()` instead of `contract.call()` to transfer Ether to untrusted addresses. \n- When using low-level calls, make sure all internal state changes are performed before the call is executed.\n\n## References \n\n- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy)",
      "Remediation": "# Title \nReentrancy\n\n## Relationships\n[CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)\n\n## Description\n\nOne of the major dangers of calling external contracts is that they can take over the control flow. In the reentrancy attack (a.k.a. recursive call attack), a malicious contract calls back into the calling contract before the first invocation of the function is finished. This may cause the different invocations of the function to interact in undesirable ways.\n\n## Remediation\n\nThe best practices to avoid Reentrancy weaknesses are: \n\n- Use `transfer()` instead of `contract.call()` to transfer Ether to untrusted addresses. \n- When using low-level calls, make sure all internal state changes are performed before the call is executed.\n\n## References \n\n- [Ethereum Smart Contract Best Practices - Reentrancy](https://consensys.github.io/smart-contract-best-practices/known_attacks/#reentrancy)"
    }
  },
  "SWC-108": {
    "markdown": "# Title \nFunction Variable Visibility \n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nLabeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.\n\n## Remediation\n\nVariables can be specified as being `public`, `internal` or `private`. Explicitly define visibility for all state variables.\n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)",
    "content": {
      "Title": "Function Variable Visibility \n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nLabeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.\n\n## Remediation\n\nVariables can be specified as being `public`, `internal` or `private`. Explicitly define visibility for all state variables.\n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)",
      "Relationships": "# Title \nFunction Variable Visibility \n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nLabeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.\n\n## Remediation\n\nVariables can be specified as being `public`, `internal` or `private`. Explicitly define visibility for all state variables.\n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)",
      "Description": "# Title \nFunction Variable Visibility \n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nLabeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.\n\n## Remediation\n\nVariables can be specified as being `public`, `internal` or `private`. Explicitly define visibility for all state variables.\n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)",
      "Remediation": "# Title \nFunction Variable Visibility \n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](https://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nLabeling the visibility explicitly makes it easier to catch incorrect assumptions about who can access the variable.\n\n## Remediation\n\nVariables can be specified as being `public`, `internal` or `private`. Explicitly define visibility for all state variables.\n\n## References \n- [Ethereum Smart Contract Best Practices - Explicitly mark visibility in functions and state variables](https://consensys.github.io/smart-contract-best-practices/recommendations/#explicitly-mark-visibility-in-functions-and-state-variables)"
    }
  },
  "SWC-109": {
    "markdown": "# Title \nUninitialised Storage Pointer\n\n## Relationships\n[CWE-824: Access of Uninitialized Pointer](https://cwe.mitre.org/data/definitions/824.html)\n\n## Description \nUninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional or unintentional vulnerabilities.\n\n## Remediation\nIt is recommended to explicitly specify the data location `memory` or `storage` when dealing with complex types to ensure they behave as expected.\n\n## References \n- [SigmaPrime - Unintialised Storage Pointers](https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1)",
    "content": {
      "Title": "Uninitialised Storage Pointer\n\n## Relationships\n[CWE-824: Access of Uninitialized Pointer](https://cwe.mitre.org/data/definitions/824.html)\n\n## Description \nUninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional or unintentional vulnerabilities.\n\n## Remediation\nIt is recommended to explicitly specify the data location `memory` or `storage` when dealing with complex types to ensure they behave as expected.\n\n## References \n- [SigmaPrime - Unintialised Storage Pointers](https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1)",
      "Relationships": "# Title \nUninitialised Storage Pointer\n\n## Relationships\n[CWE-824: Access of Uninitialized Pointer](https://cwe.mitre.org/data/definitions/824.html)\n\n## Description \nUninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional or unintentional vulnerabilities.\n\n## Remediation\nIt is recommended to explicitly specify the data location `memory` or `storage` when dealing with complex types to ensure they behave as expected.\n\n## References \n- [SigmaPrime - Unintialised Storage Pointers](https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1)",
      "Description": "# Title \nUninitialised Storage Pointer\n\n## Relationships\n[CWE-824: Access of Uninitialized Pointer](https://cwe.mitre.org/data/definitions/824.html)\n\n## Description \nUninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional or unintentional vulnerabilities.\n\n## Remediation\nIt is recommended to explicitly specify the data location `memory` or `storage` when dealing with complex types to ensure they behave as expected.\n\n## References \n- [SigmaPrime - Unintialised Storage Pointers](https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1)",
      "Remediation": "# Title \nUninitialised Storage Pointer\n\n## Relationships\n[CWE-824: Access of Uninitialized Pointer](https://cwe.mitre.org/data/definitions/824.html)\n\n## Description \nUninitialised local storage variables can point to other unexpected storage variables in the contract, leading to intentional or unintentional vulnerabilities.\n\n## Remediation\nIt is recommended to explicitly specify the data location `memory` or `storage` when dealing with complex types to ensure they behave as expected.\n\n## References \n- [SigmaPrime - Unintialised Storage Pointers](https://github.com/sigp/solidity-security-blog#unintialised-storage-pointers-1)"
    }
  },
  "SWC-110": {
    "markdown": "# Title \nAssert Violation\n\n## Relationships\n\n[CWE-617: Reachable Assertion](https://cwe.mitre.org/data/definitions/617.html)\n\n## Description \n\nThe Solidity `assert()` function is meant to assert invariants. Properly functioning code should *never* reach a failing assert statement. A reachable assertion can mean one of two things:\n\n1. A bug exists in the contract that allows it to enter an invalid state;\n2. The `assert` statement is used incorrectly, e.g. to validate inputs.\n\n## Remediation\n\nConsider whether the condition checked in the `assert()` is actually an invariant. If not, replace the `assert()` statement with a `require()` statement.\n\nIf the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.\n\n## References\n\n- [The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM](https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57)\n",
    "content": {
      "Title": "Assert Violation\n\n## Relationships\n\n[CWE-617: Reachable Assertion](https://cwe.mitre.org/data/definitions/617.html)\n\n## Description \n\nThe Solidity `assert()` function is meant to assert invariants. Properly functioning code should *never* reach a failing assert statement. A reachable assertion can mean one of two things:\n\n1. A bug exists in the contract that allows it to enter an invalid state;\n2. The `assert` statement is used incorrectly, e.g. to validate inputs.\n\n## Remediation\n\nConsider whether the condition checked in the `assert()` is actually an invariant. If not, replace the `assert()` statement with a `require()` statement.\n\nIf the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.\n\n## References\n\n- [The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM](https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57)",
      "Relationships": "# Title \nAssert Violation\n\n## Relationships\n\n[CWE-617: Reachable Assertion](https://cwe.mitre.org/data/definitions/617.html)\n\n## Description \n\nThe Solidity `assert()` function is meant to assert invariants. Properly functioning code should *never* reach a failing assert statement. A reachable assertion can mean one of two things:\n\n1. A bug exists in the contract that allows it to enter an invalid state;\n2. The `assert` statement is used incorrectly, e.g. to validate inputs.\n\n## Remediation\n\nConsider whether the condition checked in the `assert()` is actually an invariant. If not, replace the `assert()` statement with a `require()` statement.\n\nIf the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.\n\n## References\n\n- [The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM](https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57)",
      "Description": "# Title \nAssert Violation\n\n## Relationships\n\n[CWE-617: Reachable Assertion](https://cwe.mitre.org/data/definitions/617.html)\n\n## Description \n\nThe Solidity `assert()` function is meant to assert invariants. Properly functioning code should *never* reach a failing assert statement. A reachable assertion can mean one of two things:\n\n1. A bug exists in the contract that allows it to enter an invalid state;\n2. The `assert` statement is used incorrectly, e.g. to validate inputs.\n\n## Remediation\n\nConsider whether the condition checked in the `assert()` is actually an invariant. If not, replace the `assert()` statement with a `require()` statement.\n\nIf the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.\n\n## References\n\n- [The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM](https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57)",
      "Remediation": "# Title \nAssert Violation\n\n## Relationships\n\n[CWE-617: Reachable Assertion](https://cwe.mitre.org/data/definitions/617.html)\n\n## Description \n\nThe Solidity `assert()` function is meant to assert invariants. Properly functioning code should *never* reach a failing assert statement. A reachable assertion can mean one of two things:\n\n1. A bug exists in the contract that allows it to enter an invalid state;\n2. The `assert` statement is used incorrectly, e.g. to validate inputs.\n\n## Remediation\n\nConsider whether the condition checked in the `assert()` is actually an invariant. If not, replace the `assert()` statement with a `require()` statement.\n\nIf the exception is indeed caused by unexpected behaviour of the code, fix the underlying bug(s) that allow the assertion to be violated.\n\n## References\n\n- [The use of revert(), assert(), and require() in Solidity, and the new REVERT opcode in the EVM](https://media.consensys.net/when-to-use-revert-assert-and-require-in-solidity-61fb2c0e5a57)"
    }
  },
  "SWC-111": {
    "markdown": "# Title \nUse of Deprecated Soldity Functions\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n\n```TODO\n\nRefers to use of deprecated Solidity aliases such as suicide(), sha3(), throw().\n\nAlso possibly send()?\n```\n\n## Remediation\n\n\n## References ",
    "content": {
      "Title": "Use of Deprecated Soldity Functions\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n\n```TODO\n\nRefers to use of deprecated Solidity aliases such as suicide(), sha3(), throw().\n\nAlso possibly send()?\n```\n\n## Remediation\n\n\n## References",
      "Relationships": "# Title \nUse of Deprecated Soldity Functions\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n\n```TODO\n\nRefers to use of deprecated Solidity aliases such as suicide(), sha3(), throw().\n\nAlso possibly send()?\n```\n\n## Remediation\n\n\n## References",
      "Description": "# Title \nUse of Deprecated Soldity Functions\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n\n```TODO\n\nRefers to use of deprecated Solidity aliases such as suicide(), sha3(), throw().\n\nAlso possibly send()?\n```\n\n## Remediation\n\n\n## References",
      "Remediation": "# Title \nUse of Deprecated Soldity Functions\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n\n```TODO\n\nRefers to use of deprecated Solidity aliases such as suicide(), sha3(), throw().\n\nAlso possibly send()?\n```\n\n## Remediation\n\n\n## References"
    }
  },
  "SWC-112": {
    "markdown": "# Title \nDelegatecall to Untrusted Callee\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\nThere exists a special variant of a message call, named `delegatecall` which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and `msg.sender` and `msg.value` do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.\n\n## Remediation\n\nUse `delegatecall` with caution and make sure to never call into untrusted contracts. If the target address is derived from user input enure to check it against a whitelist of trusted contracts.\n\n## References\n\n- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)\n- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)\n- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)\n",
    "content": {
      "Title": "Delegatecall to Untrusted Callee\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\nThere exists a special variant of a message call, named `delegatecall` which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and `msg.sender` and `msg.value` do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.\n\n## Remediation\n\nUse `delegatecall` with caution and make sure to never call into untrusted contracts. If the target address is derived from user input enure to check it against a whitelist of trusted contracts.\n\n## References\n\n- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)\n- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)\n- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)",
      "Relationships": "# Title \nDelegatecall to Untrusted Callee\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\nThere exists a special variant of a message call, named `delegatecall` which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and `msg.sender` and `msg.value` do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.\n\n## Remediation\n\nUse `delegatecall` with caution and make sure to never call into untrusted contracts. If the target address is derived from user input enure to check it against a whitelist of trusted contracts.\n\n## References\n\n- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)\n- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)\n- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)",
      "Description": "# Title \nDelegatecall to Untrusted Callee\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\nThere exists a special variant of a message call, named `delegatecall` which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and `msg.sender` and `msg.value` do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.\n\n## Remediation\n\nUse `delegatecall` with caution and make sure to never call into untrusted contracts. If the target address is derived from user input enure to check it against a whitelist of trusted contracts.\n\n## References\n\n- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)\n- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)\n- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)",
      "Remediation": "# Title \nDelegatecall to Untrusted Callee\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\nThere exists a special variant of a message call, named `delegatecall` which is identical to a message call apart from the fact that the code at the target address is executed in the context of the calling contract and `msg.sender` and `msg.value` do not change their values. This allows a smart contract to dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract.\n\nCalling into untrusted contracts is very dangerous, as the code at the target address can change any storage values of the caller and has full control over the caller's balance.\n\n## Remediation\n\nUse `delegatecall` with caution and make sure to never call into untrusted contracts. If the target address is derived from user input enure to check it against a whitelist of trusted contracts.\n\n## References\n\n- [Solidity Documentation - Delegatecall / Callcode and Libraries](https://solidity.readthedocs.io/en/latest/introduction-to-smart-contracts.html#delegatecall-callcode-and-libraries)\n- [How to Secure Your Smart Contracts: 6 Solidity Vulnerabilities and how to avoid them (Part 1) - Delegate Call](https://medium.com/loom-network/how-to-secure-your-smart-contracts-6-solidity-vulnerabilities-and-how-to-avoid-them-part-1-c33048d4d17d)\n- [Solidity Security: Comprehensive list of known attack vectors and common anti-patterns - Delegatecall](https://blog.sigmaprime.io/solidity-security.html#delegatecall)"
    }
  },
  "SWC-113": {
    "markdown": "# Title \n\nMultiple Message Calls in a Single Transaction\n\n## Relationships\n\n[CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n\n## Description \n\nExternal calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).\n\n## Remediation\n\n Avoid combining multiple send() calls in a single transaction.\n\n## References\n\n- [ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)\n",
    "content": {
      "Title": "Multiple Message Calls in a Single Transaction\n\n## Relationships\n\n[CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n\n## Description \n\nExternal calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).\n\n## Remediation\n\n Avoid combining multiple send() calls in a single transaction.\n\n## References\n\n- [ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)",
      "Relationships": "# Title \n\nMultiple Message Calls in a Single Transaction\n\n## Relationships\n\n[CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n\n## Description \n\nExternal calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).\n\n## Remediation\n\n Avoid combining multiple send() calls in a single transaction.\n\n## References\n\n- [ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)",
      "Description": "# Title \n\nMultiple Message Calls in a Single Transaction\n\n## Relationships\n\n[CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n\n## Description \n\nExternal calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).\n\n## Remediation\n\n Avoid combining multiple send() calls in a single transaction.\n\n## References\n\n- [ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)",
      "Remediation": "# Title \n\nMultiple Message Calls in a Single Transaction\n\n## Relationships\n\n[CWE-400: Uncontrolled Resource Consumption ('Resource Exhaustion')](https://cwe.mitre.org/data/definitions/400.html)\n\n## Description \n\nExternal calls can fail accidentally or deliberately. To minimize the damage caused by such failures, it is better to isolate each external call into its own transaction that can be initiated by the recipient of the call. This is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).\n\n## Remediation\n\n Avoid combining multiple send() calls in a single transaction.\n\n## References\n\n- [ConsenSys Smart Contract Best Practices](https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls)"
    }
  },
  "SWC-114": {
    "markdown": "# Title\nTransaction Order Dependence\n\n## Relationships\n[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\n## Description\nThe Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).\n\n## Remediation\nA possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender's address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.\n\nThe best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.\n\n## References\n[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)\n[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)\n",
    "content": {
      "Title": "# Title\nTransaction Order Dependence\n\n## Relationships\n[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\n## Description\nThe Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).\n\n## Remediation\nA possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender's address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.\n\nThe best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.\n\n## References\n[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)\n[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)",
      "Relationships": "# Title\nTransaction Order Dependence\n\n## Relationships\n[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\n## Description\nThe Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).\n\n## Remediation\nA possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender's address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.\n\nThe best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.\n\n## References\n[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)\n[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)",
      "Description": "# Title\nTransaction Order Dependence\n\n## Relationships\n[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\n## Description\nThe Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).\n\n## Remediation\nA possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender's address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.\n\nThe best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.\n\n## References\n[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)\n[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)",
      "Remediation": "# Title\nTransaction Order Dependence\n\n## Relationships\n[CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')](https://cwe.mitre.org/data/definitions/362.html)\n\n## Description\nThe Ethereum network processes transactions in blocks with new blocks getting confirmed around every 17 seconds. The miners look at transactions they have received and select which transactions to include in a block, based who has paid a high enough gas price to be included. Additionally, when transactions are sent to the Ethereum network they are forwarded to each node for processing. Thus, a person who is running an Ethereum node can tell which transactions are going to occur before they are finalized.A race condition vulnerability occurs when code depends on the order of the transactions submitted to it.\n\nThe simplest example of a race condition is when a smart contract give a reward for submitting information. Say a contract will give out 1 token to the first person who solves a math problem. Alice solves the problem and submits the answer to the network with a standard gas price. Eve runs an Ethereum node and can see the answer to the math problem in the transaction that Alice submitted to the network. So Eve submits the answer to the network with a much higher gas price and thus it gets processed and committed before Alice's transaction. Eve receives one token and Alice gets nothing, even though it was Alice who worked to solve the problem. A common way this occurs in practice is when a contract rewards people for calling out bad behavior in a protocol by giving a bad actor's deposit to the person who proved they were misbehaving.\n\nThe race condition that happens the most on the network today is the race condition in the ERC20 token standard. The ERC20 token standard includes a function called 'approve' which allows an address to approve another address to spend tokens on their behalf. Assume that Alice has approved Eve to spend n of her tokens, then Alice decides to change Eve's approval to m tokens. Alice submits a function call to approve with the value n for Eve. Eve runs a Ethereum node so knows that Alice is going to change her approval to m. Eve then submits a tranferFrom request sending n of Alice's tokens to herself, but gives it a much higher gas price than Alice's transaction. The transferFrom executes first so gives Eve n tokens and sets Eve's approval to zero. Then Alice's transaction executes and sets Eve's approval to m. Eve then sends those m tokens to herself as well. Thus Eve gets n + m tokens even thought she should have gotten at most max(n,m).\n\n## Remediation\nA possible way to remedy for race conditions in submission of information in exchange for a reward is called a commit reveal hash scheme. Instead of submitting the answer the party who has the answer submits hash(salt, address, answer) [salt being some number of their choosing] the contract stores this hash and the sender's address. To claim the reward the sender then submits a transaction with the salt, and answer. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash, if the hash matches the contract releases the reward.\n\nThe best fix for the ERC20 race condition is to add a field to the inputs of approve which is the expected current value and to have approve revert if Eve's current allowance is not what Alice indicated she was expecting. However this means that your contract no longer conforms to the ERC20 standard. If it important to your project to have the contract conform to ERC20, you can add a safe approve function. From the user perspective it is possible to mediate the ERC20 race condition by setting approvals to zero before changing them.\n\n## References\n[General Article on Race Conditions](https://medium.com/coinmonks/solidity-transaction-ordering-attacks-1193a014884e)\n[ERC20 Race Condition](https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#)"
    }
  },
  "SWC-115": {
    "markdown": "# Title \nAuthorization through tx.origin\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n`tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since `tx.origin` returns the original sender of the transaction which in this case is the authorized account.\n\n## Remediation\n\n`tx.origin` should not be used for authorization. Use `msg.sender` instead.\n\n## References\n- [Solidity Documentation - tx.origin](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n- [Ethereum Smart Contract Best Practices - Avoid using tx.origin](https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#tx-origin)\n",
    "content": {
      "Title": "Authorization through tx.origin\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n`tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since `tx.origin` returns the original sender of the transaction which in this case is the authorized account.\n\n## Remediation\n\n`tx.origin` should not be used for authorization. Use `msg.sender` instead.\n\n## References\n- [Solidity Documentation - tx.origin](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n- [Ethereum Smart Contract Best Practices - Avoid using tx.origin](https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#tx-origin)",
      "Relationships": "# Title \nAuthorization through tx.origin\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n`tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since `tx.origin` returns the original sender of the transaction which in this case is the authorized account.\n\n## Remediation\n\n`tx.origin` should not be used for authorization. Use `msg.sender` instead.\n\n## References\n- [Solidity Documentation - tx.origin](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n- [Ethereum Smart Contract Best Practices - Avoid using tx.origin](https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#tx-origin)",
      "Description": "# Title \nAuthorization through tx.origin\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n`tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since `tx.origin` returns the original sender of the transaction which in this case is the authorized account.\n\n## Remediation\n\n`tx.origin` should not be used for authorization. Use `msg.sender` instead.\n\n## References\n- [Solidity Documentation - tx.origin](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n- [Ethereum Smart Contract Best Practices - Avoid using tx.origin](https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#tx-origin)",
      "Remediation": "# Title \nAuthorization through tx.origin\n\n## Relationships\n[CWE-477: Use of Obsolete Function](https://cwe.mitre.org/data/definitions/477.html)\n\n## Description \n`tx.origin` is a global variable in Solidity which returns the address of the account that sent the transaction. Using the variable for authorization could make a contract vulnerable if an authorized account calls into a malicious contract. A call could be made to the vulnerable contract that passes the authorization check since `tx.origin` returns the original sender of the transaction which in this case is the authorized account.\n\n## Remediation\n\n`tx.origin` should not be used for authorization. Use `msg.sender` instead.\n\n## References\n- [Solidity Documentation - tx.origin](https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin)\n- [Ethereum Smart Contract Best Practices - Avoid using tx.origin](https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin)\n- [SigmaPrime - Visibility](https://github.com/sigp/solidity-security-blog#tx-origin)"
    }
  },
  "SWC-116": {
    "markdown": "# Title \nTimestamp Dependence\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\n\n## Remediation\n\n\n## References\n",
    "content": {
      "Title": "Timestamp Dependence\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Relationships": "# Title \nTimestamp Dependence\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Description": "# Title \nTimestamp Dependence\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Remediation": "# Title \nTimestamp Dependence\n\n## Relationships\n[CWE-829: Inclusion of Functionality from Untrusted Control Sphere](https://cwe.mitre.org/data/definitions/829.html)\n\n## Description \n\n\n## Remediation\n\n\n## References"
    }
  },
  "SWC-117": {
    "markdown": "# Title\nSignature Malleability\n\n## Base/Class ID\n[Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description\n\nThe implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possesion of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being `ecrecover` which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values _v_, _r_ and _s_ to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.  \n\n## Remediation\n\nA signature should never be included into a signed message hash to check if previously messages have been processed by the contract. \n\n## References\n[Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability)\n[CTF - Challenge](https://ropsten.etherscan.io/address/0x0daabce0a1261b582e0d949ebca9dff4c22c88ef#code)\n",
    "content": {
      "Title": "# Title\nSignature Malleability\n\n## Base/Class ID\n[Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description\n\nThe implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possesion of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being `ecrecover` which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values _v_, _r_ and _s_ to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.  \n\n## Remediation\n\nA signature should never be included into a signed message hash to check if previously messages have been processed by the contract. \n\n## References\n[Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability)\n[CTF - Challenge](https://ropsten.etherscan.io/address/0x0daabce0a1261b582e0d949ebca9dff4c22c88ef#code)",
      "Relationships": "# Title\nSignature Malleability\n\n## Base/Class ID\n[Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description\n\nThe implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possesion of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being `ecrecover` which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values _v_, _r_ and _s_ to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.  \n\n## Remediation\n\nA signature should never be included into a signed message hash to check if previously messages have been processed by the contract. \n\n## References\n[Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability)\n[CTF - Challenge](https://ropsten.etherscan.io/address/0x0daabce0a1261b582e0d949ebca9dff4c22c88ef#code)",
      "Description": "# Title\nSignature Malleability\n\n## Base/Class ID\n[Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description\n\nThe implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possesion of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being `ecrecover` which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values _v_, _r_ and _s_ to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.  \n\n## Remediation\n\nA signature should never be included into a signed message hash to check if previously messages have been processed by the contract. \n\n## References\n[Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability)\n[CTF - Challenge](https://ropsten.etherscan.io/address/0x0daabce0a1261b582e0d949ebca9dff4c22c88ef#code)",
      "Remediation": "# Title\nSignature Malleability\n\n## Base/Class ID\n[Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description\n\nThe implementation of a cryptographic signature system in Ethereum contracts often assumes that the signature is unique, but signatures can be altered without the possesion of the private key and still be valid. The EVM specification defines several so-called ‘precompiled’ contracts one of them being `ecrecover` which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values _v_, _r_ and _s_ to create other valid signatures. A system that performs signature verification on contract level might be susceptible to attacks if the signature is part of the signed message hash. Valid signatures could be created by a malicious user to replay previously signed messages.  \n\n## Remediation\n\nA signature should never be included into a signed message hash to check if previously messages have been processed by the contract. \n\n## References\n[Bitcoin Transaction Malleability](https://eklitzke.org/bitcoin-transaction-malleability)\n[CTF - Challenge](https://ropsten.etherscan.io/address/0x0daabce0a1261b582e0d949ebca9dff4c22c88ef#code)"
    }
  },
  "SWC-118": {
    "markdown": "# Title \nIncorrect Constructor Name \n\n## Relationships\n[CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)\n\n## Description \nConstructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name.\nThis behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly. \n\n## Remediation\n\nSolidity version 0.4.22 introduces a new `constructor` keyword that make a contructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new contructor declaration. \n\n## References\n\n- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)\n",
    "content": {
      "Title": "Incorrect Constructor Name \n\n## Relationships\n[CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)\n\n## Description \nConstructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name.\nThis behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly. \n\n## Remediation\n\nSolidity version 0.4.22 introduces a new `constructor` keyword that make a contructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new contructor declaration. \n\n## References\n\n- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)",
      "Relationships": "# Title \nIncorrect Constructor Name \n\n## Relationships\n[CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)\n\n## Description \nConstructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name.\nThis behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly. \n\n## Remediation\n\nSolidity version 0.4.22 introduces a new `constructor` keyword that make a contructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new contructor declaration. \n\n## References\n\n- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)",
      "Description": "# Title \nIncorrect Constructor Name \n\n## Relationships\n[CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)\n\n## Description \nConstructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name.\nThis behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly. \n\n## Remediation\n\nSolidity version 0.4.22 introduces a new `constructor` keyword that make a contructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new contructor declaration. \n\n## References\n\n- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)",
      "Remediation": "# Title \nIncorrect Constructor Name \n\n## Relationships\n[CWE-665: Improper Initialization](http://cwe.mitre.org/data/definitions/665.html)\n\n## Description \nConstructors are special functions that are called only once during the contract creation. They often perform critical, privileged actions such as setting the owner of the contract. Before Solidity version 0.4.22, the only way of defining a constructor was to create a function with the same name as the contract class containing it. A function meant to become a constructor becomes a normal, callable function if its name doesn't exactly match the contract name.\nThis behavior sometimes leads to security issues, in particular when smart contract code is re-used with a different name but the name of the constructor function is not changed accordingly. \n\n## Remediation\n\nSolidity version 0.4.22 introduces a new `constructor` keyword that make a contructor definitions clearer. It is therefore recommended to upgrade the contract to a recent version of the Solidity compiler and change to the new contructor declaration. \n\n## References\n\n- [SigmaPrime - Constructors with Care](https://blog.sigmaprime.io/solidity-security.html#constructors)"
    }
  },
  "SWC-119": {
    "markdown": "# Title \nShadowing State Variables\n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nSolidity allows for ambiguous naming of state variables when inheritance is used. Contract `A` with a variable `x` could inherit contract `B` that also has a state variable `x` defined. This would result in two separate versions of `x`, one of them being accessed from contract `A` and the other one from contract `B`. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues. \n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level. \n\n## Remediation\n\nReview storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.\n\n## References\n- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)\n- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)\n",
    "content": {
      "Title": "Shadowing State Variables\n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nSolidity allows for ambiguous naming of state variables when inheritance is used. Contract `A` with a variable `x` could inherit contract `B` that also has a state variable `x` defined. This would result in two separate versions of `x`, one of them being accessed from contract `A` and the other one from contract `B`. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues. \n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level. \n\n## Remediation\n\nReview storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.\n\n## References\n- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)\n- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)",
      "Relationships": "# Title \nShadowing State Variables\n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nSolidity allows for ambiguous naming of state variables when inheritance is used. Contract `A` with a variable `x` could inherit contract `B` that also has a state variable `x` defined. This would result in two separate versions of `x`, one of them being accessed from contract `A` and the other one from contract `B`. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues. \n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level. \n\n## Remediation\n\nReview storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.\n\n## References\n- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)\n- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)",
      "Description": "# Title \nShadowing State Variables\n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nSolidity allows for ambiguous naming of state variables when inheritance is used. Contract `A` with a variable `x` could inherit contract `B` that also has a state variable `x` defined. This would result in two separate versions of `x`, one of them being accessed from contract `A` and the other one from contract `B`. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues. \n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level. \n\n## Remediation\n\nReview storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.\n\n## References\n- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)\n- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)",
      "Remediation": "# Title \nShadowing State Variables\n\n## Relationships\n[CWE-710: Improper Adherence to Coding Standards](http://cwe.mitre.org/data/definitions/710.html)\n\n## Description \n\nSolidity allows for ambiguous naming of state variables when inheritance is used. Contract `A` with a variable `x` could inherit contract `B` that also has a state variable `x` defined. This would result in two separate versions of `x`, one of them being accessed from contract `A` and the other one from contract `B`. In more complex contract systems this condition could go unnoticed and subsequently lead to security issues. \n\nShadowing state variables can also occur within a single contract when there are multiple definitions on the contract and function level. \n\n## Remediation\n\nReview storage variable layouts for your contract systems carefully and remove any ambiguities. Always check for compiler warnings as they can flag the issue within a single contract.\n\n## References\n- [Issue on Solidity's Github - Shadowing of inherited state variables should be an error (override keyword)](https://github.com/ethereum/solidity/issues/2563)\n- [Issue on Solidity's Github - Warn about shadowing state variables](https://github.com/ethereum/solidity/issues/973)"
    }
  },
  "SWC-120": {
    "markdown": "# Title \nWeak Sources of Randomness  \n\n## Relationships\n[CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)\n\n## Description \n\n\n## Remediation\n\n\n## References\n\n\n",
    "content": {
      "Title": "Weak Sources of Randomness  \n\n## Relationships\n[CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Relationships": "# Title \nWeak Sources of Randomness  \n\n## Relationships\n[CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Description": "# Title \nWeak Sources of Randomness  \n\n## Relationships\n[CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Remediation": "# Title \nWeak Sources of Randomness  \n\n## Relationships\n[CWE-330: Use of Insufficiently Random Values](https://cwe.mitre.org/data/definitions/330.html)\n\n## Description \n\n\n## Remediation\n\n\n## References"
    }
  },
  "SWC-121": {
    "markdown": "# Title \nSignature Replay  \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References\n\n\n",
    "content": {
      "Title": "Signature Replay  \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Relationships": "# Title \nSignature Replay  \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Description": "# Title \nSignature Replay  \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Remediation": "# Title \nSignature Replay  \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References"
    }
  },
  "SWC-122": {
    "markdown": "# Title \nPseudo Signature Verification based on msg.sender \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References\n",
    "content": {
      "Title": "Pseudo Signature Verification based on msg.sender \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Relationships": "# Title \nPseudo Signature Verification based on msg.sender \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Description": "# Title \nPseudo Signature Verification based on msg.sender \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References",
      "Remediation": "# Title \nPseudo Signature Verification based on msg.sender \n\n## Relationships\n[CWE-347: Improper Verification of Cryptographic Signature](https://cwe.mitre.org/data/definitions/347.html)\n\n## Description \n\n\n## Remediation\n\n\n## References"
    }
  }
}